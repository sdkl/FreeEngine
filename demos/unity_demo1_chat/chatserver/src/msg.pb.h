// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: msg.proto

#ifndef PROTOBUF_msg_2eproto__INCLUDED
#define PROTOBUF_msg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace FreeEngineMsg {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_msg_2eproto();
void protobuf_AssignDesc_msg_2eproto();
void protobuf_ShutdownFile_msg_2eproto();

class FEMsg;
class FEMsg_Info;
class FEMsg_Talk;

enum FEMsg_MSG_Type {
  FEMsg_MSG_Type_Info = 1,
  FEMsg_MSG_Type_Talk = 2
};
bool FEMsg_MSG_Type_IsValid(int value);
const FEMsg_MSG_Type FEMsg_MSG_Type_MSG_Type_MIN = FEMsg_MSG_Type_Info;
const FEMsg_MSG_Type FEMsg_MSG_Type_MSG_Type_MAX = FEMsg_MSG_Type_Talk;
const int FEMsg_MSG_Type_MSG_Type_ARRAYSIZE = FEMsg_MSG_Type_MSG_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* FEMsg_MSG_Type_descriptor();
inline const ::std::string& FEMsg_MSG_Type_Name(FEMsg_MSG_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    FEMsg_MSG_Type_descriptor(), value);
}
inline bool FEMsg_MSG_Type_Parse(
    const ::std::string& name, FEMsg_MSG_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FEMsg_MSG_Type>(
    FEMsg_MSG_Type_descriptor(), name, value);
}
// ===================================================================

class FEMsg : public ::google::protobuf::Message {
 public:
  FEMsg();
  virtual ~FEMsg();

  FEMsg(const FEMsg& from);

  inline FEMsg& operator=(const FEMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FEMsg& default_instance();

  void Swap(FEMsg* other);

  // implements Message ----------------------------------------------

  FEMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FEMsg& from);
  void MergeFrom(const FEMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef FEMsg_MSG_Type MSG_Type;
  static const MSG_Type Info = FEMsg_MSG_Type_Info;
  static const MSG_Type Talk = FEMsg_MSG_Type_Talk;
  static inline bool MSG_Type_IsValid(int value) {
    return FEMsg_MSG_Type_IsValid(value);
  }
  static const MSG_Type MSG_Type_MIN =
    FEMsg_MSG_Type_MSG_Type_MIN;
  static const MSG_Type MSG_Type_MAX =
    FEMsg_MSG_Type_MSG_Type_MAX;
  static const int MSG_Type_ARRAYSIZE =
    FEMsg_MSG_Type_MSG_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MSG_Type_descriptor() {
    return FEMsg_MSG_Type_descriptor();
  }
  static inline const ::std::string& MSG_Type_Name(MSG_Type value) {
    return FEMsg_MSG_Type_Name(value);
  }
  static inline bool MSG_Type_Parse(const ::std::string& name,
      MSG_Type* value) {
    return FEMsg_MSG_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .FreeEngineMsg.FEMsg.MSG_Type msgtype = 1;
  inline bool has_msgtype() const;
  inline void clear_msgtype();
  static const int kMsgtypeFieldNumber = 1;
  inline ::FreeEngineMsg::FEMsg_MSG_Type msgtype() const;
  inline void set_msgtype(::FreeEngineMsg::FEMsg_MSG_Type value);

  // optional .FreeEngineMsg.FEMsg_Info gameInfo = 2;
  inline bool has_gameinfo() const;
  inline void clear_gameinfo();
  static const int kGameInfoFieldNumber = 2;
  inline const ::FreeEngineMsg::FEMsg_Info& gameinfo() const;
  inline ::FreeEngineMsg::FEMsg_Info* mutable_gameinfo();
  inline ::FreeEngineMsg::FEMsg_Info* release_gameinfo();
  inline void set_allocated_gameinfo(::FreeEngineMsg::FEMsg_Info* gameinfo);

  // optional .FreeEngineMsg.FEMsg_Talk talk = 3;
  inline bool has_talk() const;
  inline void clear_talk();
  static const int kTalkFieldNumber = 3;
  inline const ::FreeEngineMsg::FEMsg_Talk& talk() const;
  inline ::FreeEngineMsg::FEMsg_Talk* mutable_talk();
  inline ::FreeEngineMsg::FEMsg_Talk* release_talk();
  inline void set_allocated_talk(::FreeEngineMsg::FEMsg_Talk* talk);

  // @@protoc_insertion_point(class_scope:FreeEngineMsg.FEMsg)
 private:
  inline void set_has_msgtype();
  inline void clear_has_msgtype();
  inline void set_has_gameinfo();
  inline void clear_has_gameinfo();
  inline void set_has_talk();
  inline void clear_has_talk();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::FreeEngineMsg::FEMsg_Info* gameinfo_;
  ::FreeEngineMsg::FEMsg_Talk* talk_;
  int msgtype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static FEMsg* default_instance_;
};
// -------------------------------------------------------------------

class FEMsg_Info : public ::google::protobuf::Message {
 public:
  FEMsg_Info();
  virtual ~FEMsg_Info();

  FEMsg_Info(const FEMsg_Info& from);

  inline FEMsg_Info& operator=(const FEMsg_Info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FEMsg_Info& default_instance();

  void Swap(FEMsg_Info* other);

  // implements Message ----------------------------------------------

  FEMsg_Info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FEMsg_Info& from);
  void MergeFrom(const FEMsg_Info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // optional string newVersionURL = 2;
  inline bool has_newversionurl() const;
  inline void clear_newversionurl();
  static const int kNewVersionURLFieldNumber = 2;
  inline const ::std::string& newversionurl() const;
  inline void set_newversionurl(const ::std::string& value);
  inline void set_newversionurl(const char* value);
  inline void set_newversionurl(const char* value, size_t size);
  inline ::std::string* mutable_newversionurl();
  inline ::std::string* release_newversionurl();
  inline void set_allocated_newversionurl(::std::string* newversionurl);

  // optional string protoVersion = 3;
  inline bool has_protoversion() const;
  inline void clear_protoversion();
  static const int kProtoVersionFieldNumber = 3;
  inline const ::std::string& protoversion() const;
  inline void set_protoversion(const ::std::string& value);
  inline void set_protoversion(const char* value);
  inline void set_protoversion(const char* value, size_t size);
  inline ::std::string* mutable_protoversion();
  inline ::std::string* release_protoversion();
  inline void set_allocated_protoversion(::std::string* protoversion);

  // @@protoc_insertion_point(class_scope:FreeEngineMsg.FEMsg_Info)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_newversionurl();
  inline void clear_has_newversionurl();
  inline void set_has_protoversion();
  inline void clear_has_protoversion();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* version_;
  ::std::string* newversionurl_;
  ::std::string* protoversion_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static FEMsg_Info* default_instance_;
};
// -------------------------------------------------------------------

class FEMsg_Talk : public ::google::protobuf::Message {
 public:
  FEMsg_Talk();
  virtual ~FEMsg_Talk();

  FEMsg_Talk(const FEMsg_Talk& from);

  inline FEMsg_Talk& operator=(const FEMsg_Talk& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FEMsg_Talk& default_instance();

  void Swap(FEMsg_Talk* other);

  // implements Message ----------------------------------------------

  FEMsg_Talk* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FEMsg_Talk& from);
  void MergeFrom(const FEMsg_Talk& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string sender = 1;
  inline bool has_sender() const;
  inline void clear_sender();
  static const int kSenderFieldNumber = 1;
  inline const ::std::string& sender() const;
  inline void set_sender(const ::std::string& value);
  inline void set_sender(const char* value);
  inline void set_sender(const char* value, size_t size);
  inline ::std::string* mutable_sender();
  inline ::std::string* release_sender();
  inline void set_allocated_sender(::std::string* sender);

  // optional string content = 2;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 2;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // @@protoc_insertion_point(class_scope:FreeEngineMsg.FEMsg_Talk)
 private:
  inline void set_has_sender();
  inline void clear_has_sender();
  inline void set_has_content();
  inline void clear_has_content();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* sender_;
  ::std::string* content_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static FEMsg_Talk* default_instance_;
};
// ===================================================================


// ===================================================================

// FEMsg

// required .FreeEngineMsg.FEMsg.MSG_Type msgtype = 1;
inline bool FEMsg::has_msgtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FEMsg::set_has_msgtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FEMsg::clear_has_msgtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FEMsg::clear_msgtype() {
  msgtype_ = 1;
  clear_has_msgtype();
}
inline ::FreeEngineMsg::FEMsg_MSG_Type FEMsg::msgtype() const {
  return static_cast< ::FreeEngineMsg::FEMsg_MSG_Type >(msgtype_);
}
inline void FEMsg::set_msgtype(::FreeEngineMsg::FEMsg_MSG_Type value) {
  assert(::FreeEngineMsg::FEMsg_MSG_Type_IsValid(value));
  set_has_msgtype();
  msgtype_ = value;
}

// optional .FreeEngineMsg.FEMsg_Info gameInfo = 2;
inline bool FEMsg::has_gameinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FEMsg::set_has_gameinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FEMsg::clear_has_gameinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FEMsg::clear_gameinfo() {
  if (gameinfo_ != NULL) gameinfo_->::FreeEngineMsg::FEMsg_Info::Clear();
  clear_has_gameinfo();
}
inline const ::FreeEngineMsg::FEMsg_Info& FEMsg::gameinfo() const {
  return gameinfo_ != NULL ? *gameinfo_ : *default_instance_->gameinfo_;
}
inline ::FreeEngineMsg::FEMsg_Info* FEMsg::mutable_gameinfo() {
  set_has_gameinfo();
  if (gameinfo_ == NULL) gameinfo_ = new ::FreeEngineMsg::FEMsg_Info;
  return gameinfo_;
}
inline ::FreeEngineMsg::FEMsg_Info* FEMsg::release_gameinfo() {
  clear_has_gameinfo();
  ::FreeEngineMsg::FEMsg_Info* temp = gameinfo_;
  gameinfo_ = NULL;
  return temp;
}
inline void FEMsg::set_allocated_gameinfo(::FreeEngineMsg::FEMsg_Info* gameinfo) {
  delete gameinfo_;
  gameinfo_ = gameinfo;
  if (gameinfo) {
    set_has_gameinfo();
  } else {
    clear_has_gameinfo();
  }
}

// optional .FreeEngineMsg.FEMsg_Talk talk = 3;
inline bool FEMsg::has_talk() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FEMsg::set_has_talk() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FEMsg::clear_has_talk() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FEMsg::clear_talk() {
  if (talk_ != NULL) talk_->::FreeEngineMsg::FEMsg_Talk::Clear();
  clear_has_talk();
}
inline const ::FreeEngineMsg::FEMsg_Talk& FEMsg::talk() const {
  return talk_ != NULL ? *talk_ : *default_instance_->talk_;
}
inline ::FreeEngineMsg::FEMsg_Talk* FEMsg::mutable_talk() {
  set_has_talk();
  if (talk_ == NULL) talk_ = new ::FreeEngineMsg::FEMsg_Talk;
  return talk_;
}
inline ::FreeEngineMsg::FEMsg_Talk* FEMsg::release_talk() {
  clear_has_talk();
  ::FreeEngineMsg::FEMsg_Talk* temp = talk_;
  talk_ = NULL;
  return temp;
}
inline void FEMsg::set_allocated_talk(::FreeEngineMsg::FEMsg_Talk* talk) {
  delete talk_;
  talk_ = talk;
  if (talk) {
    set_has_talk();
  } else {
    clear_has_talk();
  }
}

// -------------------------------------------------------------------

// FEMsg_Info

// optional string version = 1;
inline bool FEMsg_Info::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FEMsg_Info::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FEMsg_Info::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FEMsg_Info::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& FEMsg_Info::version() const {
  return *version_;
}
inline void FEMsg_Info::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void FEMsg_Info::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void FEMsg_Info::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FEMsg_Info::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* FEMsg_Info::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FEMsg_Info::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string newVersionURL = 2;
inline bool FEMsg_Info::has_newversionurl() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FEMsg_Info::set_has_newversionurl() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FEMsg_Info::clear_has_newversionurl() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FEMsg_Info::clear_newversionurl() {
  if (newversionurl_ != &::google::protobuf::internal::kEmptyString) {
    newversionurl_->clear();
  }
  clear_has_newversionurl();
}
inline const ::std::string& FEMsg_Info::newversionurl() const {
  return *newversionurl_;
}
inline void FEMsg_Info::set_newversionurl(const ::std::string& value) {
  set_has_newversionurl();
  if (newversionurl_ == &::google::protobuf::internal::kEmptyString) {
    newversionurl_ = new ::std::string;
  }
  newversionurl_->assign(value);
}
inline void FEMsg_Info::set_newversionurl(const char* value) {
  set_has_newversionurl();
  if (newversionurl_ == &::google::protobuf::internal::kEmptyString) {
    newversionurl_ = new ::std::string;
  }
  newversionurl_->assign(value);
}
inline void FEMsg_Info::set_newversionurl(const char* value, size_t size) {
  set_has_newversionurl();
  if (newversionurl_ == &::google::protobuf::internal::kEmptyString) {
    newversionurl_ = new ::std::string;
  }
  newversionurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FEMsg_Info::mutable_newversionurl() {
  set_has_newversionurl();
  if (newversionurl_ == &::google::protobuf::internal::kEmptyString) {
    newversionurl_ = new ::std::string;
  }
  return newversionurl_;
}
inline ::std::string* FEMsg_Info::release_newversionurl() {
  clear_has_newversionurl();
  if (newversionurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = newversionurl_;
    newversionurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FEMsg_Info::set_allocated_newversionurl(::std::string* newversionurl) {
  if (newversionurl_ != &::google::protobuf::internal::kEmptyString) {
    delete newversionurl_;
  }
  if (newversionurl) {
    set_has_newversionurl();
    newversionurl_ = newversionurl;
  } else {
    clear_has_newversionurl();
    newversionurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string protoVersion = 3;
inline bool FEMsg_Info::has_protoversion() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FEMsg_Info::set_has_protoversion() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FEMsg_Info::clear_has_protoversion() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FEMsg_Info::clear_protoversion() {
  if (protoversion_ != &::google::protobuf::internal::kEmptyString) {
    protoversion_->clear();
  }
  clear_has_protoversion();
}
inline const ::std::string& FEMsg_Info::protoversion() const {
  return *protoversion_;
}
inline void FEMsg_Info::set_protoversion(const ::std::string& value) {
  set_has_protoversion();
  if (protoversion_ == &::google::protobuf::internal::kEmptyString) {
    protoversion_ = new ::std::string;
  }
  protoversion_->assign(value);
}
inline void FEMsg_Info::set_protoversion(const char* value) {
  set_has_protoversion();
  if (protoversion_ == &::google::protobuf::internal::kEmptyString) {
    protoversion_ = new ::std::string;
  }
  protoversion_->assign(value);
}
inline void FEMsg_Info::set_protoversion(const char* value, size_t size) {
  set_has_protoversion();
  if (protoversion_ == &::google::protobuf::internal::kEmptyString) {
    protoversion_ = new ::std::string;
  }
  protoversion_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FEMsg_Info::mutable_protoversion() {
  set_has_protoversion();
  if (protoversion_ == &::google::protobuf::internal::kEmptyString) {
    protoversion_ = new ::std::string;
  }
  return protoversion_;
}
inline ::std::string* FEMsg_Info::release_protoversion() {
  clear_has_protoversion();
  if (protoversion_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = protoversion_;
    protoversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FEMsg_Info::set_allocated_protoversion(::std::string* protoversion) {
  if (protoversion_ != &::google::protobuf::internal::kEmptyString) {
    delete protoversion_;
  }
  if (protoversion) {
    set_has_protoversion();
    protoversion_ = protoversion;
  } else {
    clear_has_protoversion();
    protoversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// FEMsg_Talk

// optional string sender = 1;
inline bool FEMsg_Talk::has_sender() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FEMsg_Talk::set_has_sender() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FEMsg_Talk::clear_has_sender() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FEMsg_Talk::clear_sender() {
  if (sender_ != &::google::protobuf::internal::kEmptyString) {
    sender_->clear();
  }
  clear_has_sender();
}
inline const ::std::string& FEMsg_Talk::sender() const {
  return *sender_;
}
inline void FEMsg_Talk::set_sender(const ::std::string& value) {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  sender_->assign(value);
}
inline void FEMsg_Talk::set_sender(const char* value) {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  sender_->assign(value);
}
inline void FEMsg_Talk::set_sender(const char* value, size_t size) {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  sender_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FEMsg_Talk::mutable_sender() {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  return sender_;
}
inline ::std::string* FEMsg_Talk::release_sender() {
  clear_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sender_;
    sender_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FEMsg_Talk::set_allocated_sender(::std::string* sender) {
  if (sender_ != &::google::protobuf::internal::kEmptyString) {
    delete sender_;
  }
  if (sender) {
    set_has_sender();
    sender_ = sender;
  } else {
    clear_has_sender();
    sender_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string content = 2;
inline bool FEMsg_Talk::has_content() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FEMsg_Talk::set_has_content() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FEMsg_Talk::clear_has_content() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FEMsg_Talk::clear_content() {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& FEMsg_Talk::content() const {
  return *content_;
}
inline void FEMsg_Talk::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void FEMsg_Talk::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void FEMsg_Talk::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FEMsg_Talk::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  return content_;
}
inline ::std::string* FEMsg_Talk::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FEMsg_Talk::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace FreeEngineMsg

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::FreeEngineMsg::FEMsg_MSG_Type>() {
  return ::FreeEngineMsg::FEMsg_MSG_Type_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_msg_2eproto__INCLUDED
